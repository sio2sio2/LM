




<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>4. Transformación de datos &#8212; documentación de Lenguajes de Marcas - rolling</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/cloud.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" />
    <link rel="stylesheet" href="../_static/general.css" type="text/css" />
    <link rel="stylesheet" href="../_static/particular.css" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noticia+Text:400,i,b,bi|Open+Sans:400,i,b,bi|Roboto+Mono:400,i,b,bi&amp;display=swap" type="text/css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/translations.js"></script>
    <script src="../_static/design-tabs.js"></script>

    
    
     
        <script src="../_static/jquery.cookie.js"></script>
    

    
     
        <script src="../_static/cloud.base.js"></script>
    

    
     
        <script src="../_static/cloud.js"></script>
    

    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="5. Almacenamiento" href="../05.almacenamiento/index.html" />
    <link rel="prev" title="3.2. JSONPath" href="../03.consulta/02.jsonpath.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head><body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../05.almacenamiento/index.html" title="5. Almacenamiento"
             accesskey="N">siguiente</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../03.consulta/02.jsonpath.html" title="3.2. JSONPath"
             accesskey="P">anterior</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">documentación de Lenguajes de Marcas - rolling</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4. </span>Transformación de datos</a></li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="transformacion-de-datos">
<span id="lm-ut4"></span><h1><span class="section-number">4. </span>Transformación de datos<a class="headerlink" href="#transformacion-de-datos" title="Enlace permanente a este encabezado">¶</a></h1>
<p>Habitualmente de los datos almacenados en documentos sólo requerimos obtener una
parte de ellos u obtenerlos todos, pero en un formato distinto. En esta unidad
trataremos los lenguajes que permiten la conversión entre distintos documentos de
datos, en particular entre distintos documentos <abbr title="eXtensible  Markup Language">XML</abbr>, para lo cual requeriremos
las técnicas de <a class="reference internal" href="../03.consulta/index.html#lm-ut3"><span class="std std-ref">Consulta de datos</span></a> aprendidas en la unidad anterior.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Complementaria a esta tarea, se encuentra la de la extracción de datos
almacenados en bases de datos, que requiere consultar (<a class="reference internal" href="../03.consulta/index.html#lm-ut3"><span class="std std-ref">Consulta de datos</span></a>) y
generar una salida (<a class="reference internal" href="#lm-ut4"><span class="std std-ref">Transformación de datos</span></a>). Esto, sin embargo, se reserva para
<a class="reference internal" href="../05.almacenamiento/index.html#lm-ut5"><span class="std std-ref">la unidad siguiente dedicada al almacenamiento</span></a>.</p>
</div>
<p>Centraremos el estudio en el <abbr title="eXtensible  Markup Language">XML</abbr>, para lo cual existen dos grandes lenguajes:</p>
<ul class="simple">
<li><p><em>XQuery</em>, que permite conversiones sencillas y al que dedicaremos el resto
de la unidad.</p></li>
<li><p><abbr title="eXtensible Stylesheet Language Transformations">XSLT</abbr>, que permite conversiones mucho más complejas y que, por ello, requiere
un estudio más detallado y extenso.</p></li>
</ul>
<section id="xquery">
<span id="id1"></span><h2><span class="section-number">4.1. </span>XQuery<a class="headerlink" href="#xquery" title="Enlace permanente a este encabezado">¶</a></h2>
<p><em class="dfn">XQuery</em> es un lenguaje de consulta que permite obtener una salida <abbr title="eXtensible  Markup Language">XML</abbr>
(aunque no necesariamente) a partir de una fuente <abbr title="eXtensible  Markup Language">XML</abbr> (aunque, de nuevo, no
necesariamente). Para ello, usa <a class="reference internal" href="../03.consulta/01.xpath.html#xpath"><span class="std std-ref">XPath</span></a> como herramienta de selección la
información y una estructura prototípica llamada <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr> por las cinco
cláusulas con las que se construye originariamente<a class="footnote-reference brackets" href="#id4" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Cumple en el mundo
<abbr title="eXtensible  Markup Language">XML</abbr> exactamente la misma función que las cláusula <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> en el mundo
<abbr title="Strctured Query Language">SQL</abbr>.</p>
<p>En cualquier caso, aunque lo que caracteriza a <em>XQuery</em> es la estructura
<abbr title="For, Let, Where, Order by, Return">FLWOR</abbr>, esta no es obligatoria, y una consulta <em>XQuery</em> puede crearse
únicamente con el contenido del <a class="reference internal" href="#xquery-return"><span class="std std-ref">RETURN del FLWOR</span></a> (sin
expresar el propio <code class="docutils literal notranslate"><span class="pre">return</span></code>. Como este contenido puede ser cualquier expresión
<em>XPath</em> valida, resulta que <em>XQuery</em> es un supercojunto de <em>XPath</em>, o lo que es
lo mismo, toda expresión <em>XPath</em> es una consulta <em>XQuery</em> válida.</p>
<p>Tres son las versiones que ha tenido este lenguaje:</p>
<dl class="simple">
<dt><a class="reference external" href="https://www.w3.org/TR/2007/REC-xquery-20070123/">Versión 1</a></dt><dd><p>Desarrollada desde los comienzos de <em>XPath</em> en 1999, se publicó
definitivamente en 2007, con lo que hace uso de <em>XPath</em> 2.0.</p>
</dd>
<dt><a class="reference external" href="https://www.w3.org/TR/xquery-30/">Versión 3</a></dt><dd><p>Publicada en 2014, con lo que incorpora <em>XPath</em> 3.0, añade como novedad
fundamental convertir a las funciones en ciudadanas de primera clase.</p>
</dd>
<dt><a class="reference external" href="https://www.w3.org/TR/xquery-31/">Versión 3.1</a></dt><dd><p>Es el última estándar aparecido en 2017, con lo que incorpora <em>XPath</em> 3.1.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No existe versión <strong>2</strong>. La relación entre <em>XQuery</em> y <em>XPath</em> es tan
íntima que se prefirió alinear las versiones de <em>XQuery</em> con las de <em>XPath</em>.</p>
</div>
<p>Una característica importante de <em>XQuery</em> es que, a diferencia de <abbr title="eXtensible Stylesheet Language Transformations">XSLT</abbr>, no
tiene sintaxis <abbr title="eXtensible  Markup Language">XML</abbr>, aunque existe una versión normativa (<a class="reference external" href="https://www.w3.org/TR/xqueryx-31/">XQueryX</a>) que la implementa.</p>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p>Téngase presente que <em>XQuery</em> comparte el modelo de datos de
<em>XPath</em> y, por tanto, todo lo indicado respecto a los tipos en las
expresiones es también aplicable. Por ejemplo, si no se ha validado el
documento, los datos serán <code class="docutils literal notranslate"><span class="pre">xs:untypedAtomic</span></code>, que se comportan más o menos
como cadenas, nunca como números.</p>
</div>
<p>Como complemento a estos apuntes, puede consultar, además de las propias
especificaciones, estas dos extensísimas fuentes:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.altova.com/training/xquery3">XQuery 3.1 Training</a>.</p></li>
<li><p><a class="reference external" href="https://en.wikibooks.org/wiki/XQuery">Wiki sobre XQuery</a>, con abundantes
ejemplos sobre cómo resolver muchos problemas concretos.</p></li>
<li><p><a class="reference external" href="http://www.datypic.com/services/xquery/whatsnew3.html">Novedades de XQuery 3</a>, que es el índice de
un curso los añadidos de la versión 3. El curso no está, pero el solo índice
nos permite tener una enumeración de cuáles son las novedades.</p></li>
</ul>
<section id="procesadores">
<h3><span class="section-number">4.1.1. </span>Procesadores<a class="headerlink" href="#procesadores" title="Enlace permanente a este encabezado">¶</a></h3>
<p>Tenemos varias alternativas para ejecutar consultas <em>XQuery</em>:</p>
<ul>
<li><p>El programa <a class="reference external" href="https://www.videlibri.de/xidel.html">xidel</a>, que ya usamos para probar <em>XPath</em>. Podemos seguir
introduciendo la expresión con <kbd class="kbd docutils literal notranslate">-e</kbd>, ya que en principio es capaz
de distiguir una expresión <em>XQuery</em> de una de <em>XPath</em>, pero en caso de algún
problema de interpretación puede usarse la opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">xquery</kbd></kbd> en su
sustitución.</p></li>
<li><p><a class="reference internal" href="../05.almacenamiento/02.nativas.html#basex"><span class="std std-ref">BaseX</span></a>, que introduciremos mejor más adelante y tiene tanto interfaz
gráfica como de línea de comandos. Es un programa hecho en <a class="reference external" href="https://es.wikipedia.org/wiki/Java_(lenguaje_de_programaci%C3%B3n)">Java</a>, así que
necesitaremos tener instalada antes la máquina virtual. En las distribuciones
basadas en <em>Debian</em> hay paquete disponible con lo que echarlo a andar es
trivial.</p>
</li>
<li id="xquery-vscode"><p><a class="reference external" href="https://code.visualstudio.com/">Visual Studio Code</a> con la extensión <a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=DotJoshJohnson.xml">XML Tools</a>,
que requiere alguna configuración adicional:</p>
<ol class="arabic simple">
<li><p>Instalar previamente <a class="reference internal" href="../05.almacenamiento/02.nativas.html#basex"><span class="std std-ref">BaseX</span></a>.</p></li>
<li><p>Configurar la extensión para que use <em>BaseX</em> como procesador. Para ello,
necesitamos editar la configuración y añadir:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">   </span><span class="nt">&quot;xmlTools.xqueryExecutionEngine&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/usr/bin/basex&quot;</span><span class="p">,</span>
<span class="w">   </span><span class="nt">&quot;xmlTools.xqueryExecutionArguments&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="s2">&quot;-i&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;$(input)&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="s2">&quot;-o&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;$(input).output.xml&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="s2">&quot;$(script)&quot;</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p>En <em>Windows</em> la ruta será algo parecido a
<code class="file docutils literal notranslate"><span class="pre">c:\\Program</span> <span class="pre">Files</span>
<span class="pre">(x86)\\BaseX\\bin\\basex.bat</span></code>.  Obsérvese que habrá que
escapar las contrabarras.</p>
</div>
</li>
</ol>
<p>Una vez bien configurada, el modo de ejecutar la consulta es el siguiente:</p>
<ol class="loweralpha simple">
<li><p>Escribimos el archivo <code class="file docutils literal notranslate"><span class="pre">.xq</span></code> con el código de <em>XQuery</em> y con el
archivo abierto y seleccionado en el editor.</p></li>
<li><p>Ejecutamos <cite>XML Tools: Execute Query</cite>.</p></li>
<li><p>Si hay varios <abbr title="eXtensible  Markup Language">XML</abbr> en el directorio se nos preguntará sobre cual
queremos hacer la consulta, y, si hemos incluido, la opción <kbd class="kbd docutils literal notranslate">-o</kbd> en
la configuración (tal como se ha sugerido antes), se nos pedirá confirmar
el archivo de salida. Si no la incluimos, la salida se volcará
directamente en una subventana.</p></li>
<li><p>Abrimos el archivo de salida para consultar el resultado.</p></li>
</ol>
</li>
</ul>
<p id="xquery-version-declaration">Otro aspecto a tener presente al usar los procesadores es que <em>XQuery</em>, al
comienzo del código, permite especificar cuál es la versión mínima que permite
ejecutar dicho código. Por ejemplo, si usamos algo de lo indicado en <a class="reference internal" href="#xquery3"><span class="std std-ref">Cláusulas adicionales</span></a>,
el código no será compatible con <em>XQuery</em> 1.0. Los procesadores están obligados
a leer la declaración y, si no soportan esa versión de <em>XQuery</em>, a abortar la
ejecución confesando su incapacidad:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="kp">xquery</span><span class="w"> </span><span class="kp">version</span><span class="w"> </span><span class="s2">&quot;1.0&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>En ausencia de la declaración, se entenderá que se soporta la versión más baja,
esto es, 1.0.</p>
</section>
<section id="flwor-basico">
<h3><span class="section-number">4.1.2. </span><abbr title="For, Let, Where, Order by, Return">FLWOR</abbr> básico<a class="headerlink" href="#flwor-basico" title="Enlace permanente a este encabezado">¶</a></h3>
<p>La estructura <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr> es una estructura iterativa (esto es, un bucle), que en
<em>XQuery</em> (ya veremos que la versión 3 añade otras) está constituida por la
sucesión de cinco cláusulas:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(FOR | LET)+ - WHERE? - ORDER BY? - RETURN
</pre></div>
</div>
<p>donde <cite>FOR</cite> es una cláusula iterativa que asigna a una variable los ítems de
una secuencia, <cite>LET</cite> permite definir variables asignándoles valor, <cite>WHERE</cite>
define una condición para que la iteración del bucle se lleve a cabo, <cite>ORDER BY</cite>
permite ordenadar los resultados, y <cite>RETURN</cite> incluye la expresión que resultará
de cada iteración. Hemos expresado también la cardinalidad, de la que se deduce
que debe haber siempre al menos una cláusula <cite>FOR</cite> o <cite>LET</cite> y una <cite>RETURN</cite>.</p>
<p>Como las expresiones se construyen para transformar documentos <abbr title="eXtensible  Markup Language">XML</abbr> se hará
referencia a los nodos de un documento, pero nuestros primeros ejemplos los
haremos utilizando expresiones <em>XPath</em> ajenas a cualquier nodo:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="c">(: Mi primer código XQuery :)</span>
<span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;perro&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gato&quot;</span><span class="p">)</span>
<span class="k">return</span>
<span class="w">   </span><span class="s2">&quot;Mi mascota es un &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot;.&quot;</span>
</pre></div>
</div>
<p>Este código devolverá como resultado</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Mi mascota es un perro.
Mi mascota es un gato.
</pre></div>
</div>
<p>Obsérvese que para construir la secuencia hemos usado una expresión <em>XPath</em><a class="footnote-reference brackets" href="#id5" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> y para expresar cuál debe ser el resultado otra. Además, hemos aprovechado
para presentar <strong>cómo escribir comentarios</strong> dentro del código. Añadamos algunos
elementos más a la construcción:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;perro&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gato&quot;</span><span class="p">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">$</span><span class="n">como</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s2">&quot;bonito&quot;</span>
<span class="k">return</span>
<span class="w">   </span><span class="s2">&quot;Mi mascota es un &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot; &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">como</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot;.&quot;</span>
</pre></div>
</div>
<p>Este código devuelve:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Mi mascota es un perro bonito.
Mi mascota es un gato bonito.
</pre></div>
</div>
<p>También podemos probar a ordenar los resultados:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;perro&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gato&quot;</span><span class="p">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">$</span><span class="n">como</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s2">&quot;bonito&quot;</span>
<span class="k">order by</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span>
<span class="k">return</span>
<span class="w">   </span><span class="s2">&quot;Mi mascota es un &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot; &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">como</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot;.&quot;</span>
</pre></div>
</div>
<p>lo cual ordenará los resultados según la expresión <em>XPath</em> <code class="code docutils literal notranslate"><span class="pre">$animal</span></code>, o
sea, el valor de esa variable para cada iteración. Como los valores son cadenas
y las cadenas tienen ordenación, es posible hacerlo. Podríamos haber utilizado
cualquier otra expresión que devolviera valores ordenados según los criterios e
<em>XPath</em> como, por ejemplo, <code class="code docutils literal notranslate"><span class="pre">fn:string-length($animal)</span></code>.</p>
<p>Por último, podemos añadir también una condición que será una expresión <em>XPath</em>
que devuelva un resultado lógico:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;perro&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gato&quot;</span><span class="p">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">$</span><span class="n">como</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s2">&quot;bonito&quot;</span>
<span class="k">where</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s2">&quot;perro&quot;</span>
<span class="k">order by</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span>
<span class="k">return</span>
<span class="w">   </span><span class="s2">&quot;Mi mascota es un &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot; &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">como</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot;.&quot;</span>
</pre></div>
</div>
<p>En esta ocasión evitaremos tener como mascota un «<em>perro bonito</em>».</p>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p>Es importante tener claro que esta estructura iterativa, aunque
formalmente parecida a la de la programación estructurada, no actúa del mismo
modo. Las iteraciones, aunque respeten el orden al mostrar los resultados, no
tienen por qué evaluarse sucesivamente y en orden, sino que lo harán de un
modo imprecedible e incluso en paralelo. Por ello, no pueden redefinirse
variables cuyo valor cambie en el cuerpo de cada iteración (p.e. definir
nosotros un contador al que sumenos <strong>1</strong> cada vez que se ejecuta el bucle).</p>
</div>
<p>Analicemos más pormenorizadamente cada parte:</p>
<dl id="xquery-for">
<dt><strong>FOR</strong></dt><dd><p>La cláusula permite añadir un contador usando la palabra <code class="docutils literal notranslate"><span class="pre">at</span></code>. Por
ejemplo, el código</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="nv">$</span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;perro&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gato&quot;</span><span class="p">)</span>
<span class="k">return</span>
<span class="w">   </span><span class="nv">$</span><span class="n">i</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot;. Mi mascota es un &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot;.&quot;</span>
</pre></div>
</div>
<p>mostrará:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1. Mi mascota es un perro.
2. Mi mascota es un gato.
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El contador hace referencia al orden del animal en la secuencia, no
al orden de las iteraciones. Por ello, el resultado que muestra el <em>gato</em>
siempre estará asociado al <strong>2</strong>, incluso aunque usando <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">by</span></code> se
llegue a mostrar antes.</p>
</div>
<p>Como deja vislumbrar la cardinalidad antes mostrada, puede haber varios
<code class="docutils literal notranslate"><span class="pre">for</span></code> en la misma estructura:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>for $animal in (&quot;perro&quot;, &quot;gato&quot;)
for $dueño in (&quot;Marta&quot;, &quot;Francisco&quot;)
return
   $dueño || &quot; tiene un &quot; || $animal || &quot;.&quot;
</pre></div>
</div>
<p>El código devuelve:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Marta tiene un perro.
Francisco tiene un perro.
Marta tiene un gato.
Francisco tiene un gato.
</pre></div>
</div>
<p>Lo anterior también puede ser escrito con un único <code class="docutils literal notranslate"><span class="pre">for</span></code>:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>for $animal in (&quot;perro&quot;, &quot;gato&quot;),
    $dueño in (&quot;Marta&quot;, &quot;Francisco&quot;)
return
   $dueño || &quot; tiene un &quot; || $animal || &quot;.&quot;
</pre></div>
</div>
</dd>
</dl>
<dl class="simple" id="xquery-let">
<dt><strong>LET</strong></dt><dd><p>La sintaxis es la misma que para <code class="docutils literal notranslate"><span class="pre">for</span></code>: podemos usar varias cláusulas con
una definición o poner varias definiciones en una cláusula separándolas con
coma.</p>
</dd>
</dl>
<dl class="simple" id="xquery-where">
<dt><strong>WHERE</strong></dt><dd><p>No tiene especiales dificultades, salvo tener claro que se evalúa usando el
<a class="reference internal" href="../03.consulta/01.xpath.html#xpath2-valor-efect-bool"><span class="std std-ref">valor efectivo booleano</span></a> de la expresión.</p>
</dd>
</dl>
<dl class="simple" id="xquery-order-by">
<dt><strong>ORDER BY</strong></dt><dd><p>La expresión <em>XPath</em> que se evalúa debe devolver un valor para el que haya
definida un orden (un número o una cadena, por ejemplo). Los resultados  se
ordenarán de menor a mayor. Sin embargo, podemos añadir las palabras reservadas
<code class="docutils literal notranslate"><span class="pre">ascending</span></code> (que no tendrá efecto) o <code class="docutils literal notranslate"><span class="pre">descending</span></code>  que invertirá la
ordenación para que se haga de mayor a menor.</p>
</dd>
</dl>
<dl id="xquery-return">
<dt><strong>RETURN</strong></dt><dd><p>Indica mediante una expresión <em>XPath</em> qué debe devolver cada iteración del
bucle. Tenga presente que, si no generamos <a class="reference internal" href="#xquery-output-xml"><span class="std std-ref">una salida XML</span></a>, esta cláusula sólo podrá contener una expresión
<em>XPath</em>. En caso de que la cláusula devuelva una secuencia, el procesador
suele escribir cada ítem en una línea distinta. Por eso motivo:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;perro&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gato&quot;</span><span class="p">)</span>
<span class="k">return</span>
<span class="w">   </span><span class="p">(</span><span class="s2">&quot;animal:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="p">)</span>
</pre></div>
</div>
<p>devuelve:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">animal</span><span class="p">:</span>
<span class="n">perro</span>
<span class="n">animal</span><span class="p">:</span>
<span class="n">gato</span>
</pre></div>
</div>
<p>Puede, además, incluirse otra estructura <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr> lo que
creará un bucle anidado:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;perro&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gato&quot;</span><span class="p">)</span>
<span class="k">return</span>
<span class="w">   </span><span class="p">(</span>
<span class="w">      </span><span class="s2">&quot;Nombres habituales de &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot; son:&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">nombre</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;misho&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;babo&quot;</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span>
<span class="w">         </span><span class="s2">&quot;  - &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">nombre</span>
<span class="w">   </span><span class="p">)</span>
</pre></div>
</div>
<p>El código anterior devuelve la salida:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Nombres habituales de perro son:
  - misho
  - babo
Nombres habituales de gato son:
  - misho
  - babo
</pre></div>
</div>
</dd>
</dl>
</section>
<section id="construccion-de-salida-xml">
<span id="xquery-output-xml"></span><h3><span class="section-number">4.1.3. </span>Construcción de salida <abbr title="eXtensible  Markup Language">XML</abbr><a class="headerlink" href="#construccion-de-salida-xml" title="Enlace permanente a este encabezado">¶</a></h3>
<p>Hasta ahora, para ilustrar los principios de la estructura <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr>, estamos
generando resultados que son mero texto. Sin embargo, podemos también generar
una salida <abbr title="eXtensible  Markup Language">XML</abbr> y en este caso, el uso y comportamiento de <em>XQuery</em> será
ligeramente distinto:</p>
<ul class="simple">
<li><p>Antes de la estructura <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr> podemos añadir el contenido <abbr title="eXtensible  Markup Language">XML</abbr> que prologa
el que generan las iteraciones.</p></li>
<li><p>Para expresar la estructura del documento <abbr title="eXtensible  Markup Language">XML</abbr>, tenemos dos alternativas: los
contructores directos y los constructores computados, que podemos usar a
voluntad.</p></li>
</ul>
<dl id="xquery-const-directo">
<dt><strong>Constructores directos</strong></dt><dd><p>Los <em class="dfn">constructores directos</em> son aquellos que consisten en escribir
literalmente la salida <abbr title="eXtensible  Markup Language">XML</abbr> y hacerle notar al procesador que algo es una
expresión <em>XPath</em> a evaluar mediante el uso de corchetes <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;mascotas&gt;</span>
<span class="sd">&lt;!--</span><span class="l"> Ejemplo de salida XML </span><span class="sd">--&gt;</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="nv">$</span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;perro&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gato&quot;</span><span class="p">)</span>
<span class="w">   </span><span class="k">return</span>
<span class="w">      </span><span class="nt">&lt;animal</span><span class="w"> </span><span class="nt">id</span><span class="o">=</span><span class="p">&quot;{</span><span class="nv">$</span><span class="n">i</span><span class="p">}&quot;</span><span class="nt">&gt;</span><span class="p">{</span><span class="nv">$</span><span class="n">animal</span><span class="p">}</span><span class="nt">&lt;/animal&gt;</span>
<span class="p">}</span>
<span class="nt">&lt;/mascotas&gt;</span>
</pre></div>
</div>
<p>Sin embargo, cuando la entrada es un documento <abbr title="eXtensible  Markup Language">XML</abbr> tenemos que tener
cuidado, porque las expresiones no siempre serán devolverán valores atómicos
y eso influye enn el comportamiento. Por ejemplo, si generamos un <abbr title="eXtensible  Markup Language">XML</abbr> a
partir del <a class="reference internal" href="../01.intro/02b.marcas.html#xml-ejemplo"><span class="std std-ref">ejemplo sobre casilleros</span></a> usando este código</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;lista&gt;</span>
<span class="sd">&lt;!--</span><span class="l"> Una lista muy simple </span><span class="sd">--&gt;</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">   </span><span class="k">return</span>
<span class="w">      </span><span class="nt">&lt;p&gt;</span><span class="p">{</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@id</span><span class="p">}</span><span class="nt">&lt;/p&gt;</span>
<span class="p">}</span>
<span class="nt">&lt;/lista&gt;</span>
</pre></div>
</div>
<p>resultará el siguiente <abbr title="eXtensible  Markup Language">XML</abbr></p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;lista&gt;</span>
<span class="cm">&lt;!-- Una lista muy simple --&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;p1&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;p13&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;p15&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;p17&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;p28&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;p81&quot;</span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="nt">&lt;p</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;p86&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/lista&gt;</span>
</pre></div>
</div>
<p>porque <code class="docutils literal notranslate"><span class="pre">$p/&#64;id</span></code> es un nodo atributo, no una cadena. Para que el
identificador hubiera pasado a ser el contenido de los elementos <em>p</em>,
deberiamos haberlo atomizado expresamente:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;lista&gt;</span>
<span class="sd">&lt;!--</span><span class="l"> Una lista muy simple </span><span class="sd">--&gt;</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">   </span><span class="k">return</span>
<span class="w">      </span><span class="nt">&lt;p&gt;</span><span class="p">{</span><span class="nf">data</span><span class="p">(</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@id</span><span class="p">)}</span><span class="nt">&lt;/p&gt;</span>
<span class="p">}</span>
<span class="nt">&lt;/lista&gt;</span>
</pre></div>
</div>
<p>Si evaluamos un nodo elemento, nos pasará lo mismo: se escribirá el elemento,
no su valor atómico.</p>
</dd>
</dl>
<dl id="xquery-const-eval">
<dt><strong>Constructores evaluados</strong></dt><dd><p>Los <em class="dfn">constructores evaluados</em> utilizan una sintaxis no <abbr title="eXtensible  Markup Language">XML</abbr> para
expresar la estructura del <abbr title="eXtensible  Markup Language">XML</abbr> de salida. Son especialmente útiles cuando
el nombre del elemento o del atributo son dinámicos y dependen del contenido
de la entrada:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">element</span><span class="w"> </span><span class="nv">lista</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">   </span><span class="k">return</span>
<span class="w">      </span><span class="k">element</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="p">{</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@id</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Como puede verse, se usa la palabra <code class="docutils literal notranslate"><span class="pre">element</span></code> con dos argumentos: el nombre
del elemento (<em>lista</em>), que es literal y la expresión de su contenido, que,
como se obtiene a través de una expresión <em>XPath</em>, hay que encerrar entre
llaves. Por supuesto, el primer argumento también podría ser una expresión
evaluada:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">element</span><span class="w"> </span><span class="p">{</span><span class="nf">name</span><span class="p">(/</span><span class="nt">*</span><span class="p">)}</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">   </span><span class="k">return</span>
<span class="w">      </span><span class="k">element</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="p">{</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@id</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>De esta forma, el nodo raíz de la salida tendrá el mismo nombre (<em>claustro</em>)
que el del documento original. Obsérvese, además, que la evaluación de
<code class="code docutils literal notranslate"><span class="pre">$p/&#64;id</span></code> resulta un nodo atributo, por lo que el elemento <em>p</em> estará
vacío y tendrá un atributo que se llama igual que el de profesoor y con su
mismo valor.</p>
<p>Si quisiéramos dotar de más contenido a <em>p</em>, podríamos expresar tal contenido
como una secuencia:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">element</span><span class="w"> </span><span class="p">{</span><span class="nf">name</span><span class="p">(/</span><span class="nt">*</span><span class="p">)}</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">   </span><span class="k">return</span>
<span class="hll"><span class="w">      </span><span class="k">element</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="p">{(</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@id</span><span class="p">,</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">nombre</span><span class="p">)}</span>
</span><span class="p">}</span>
</pre></div>
</div>
<p>Ahora <em>p</em>, dispondrá de un atributo y de un elemento <em>nombre</em> como contenido.
Por supuesto, podemos cambiar los nombres de los atributos o los elementos
complicado un poco la expresión. Por ejemplo:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">element</span><span class="w"> </span><span class="p">{</span><span class="nf">name</span><span class="p">(/</span><span class="nt">*</span><span class="p">)}</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">   </span><span class="k">return</span>
<span class="w">      </span><span class="k">element</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="p">{(</span>
<span class="w">         </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@id</span><span class="p">,</span>
<span class="hll"><span class="w">         </span><span class="k">element</span><span class="w"> </span><span class="nv">nombre_completo</span><span class="w"> </span><span class="p">{</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">nombre</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot; &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">apellidos</span><span class="p">}</span>
</span><span class="w">      </span><span class="p">)}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>o lo mismo si queremos mezclar contructores directos y evaluados:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">element</span><span class="w"> </span><span class="p">{</span><span class="nf">name</span><span class="p">(/</span><span class="nt">*</span><span class="p">)}</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">   </span><span class="k">return</span>
<span class="w">      </span><span class="k">element</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="p">{(</span>
<span class="w">         </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@id</span><span class="p">,</span>
<span class="hll"><span class="w">         </span><span class="nt">&lt;nombre_completo&gt;</span><span class="p">{</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">nombre</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot; &quot;</span><span class="w"> </span><span class="o">||</span><span class="w">  </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">apellidos</span><span class="p">}</span><span class="nt">&lt;/nombre_completo&gt;</span>
</span><span class="w">      </span><span class="p">)}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sólo hemos ilustrado los constructores evaluados para elementos, pero los hay
también para los demás componentes de un <abbr title="eXtensible  Markup Language">XML</abbr> como atributos
(<code class="code docutils literal notranslate"><span class="pre">attribute</span> <span class="pre">nombre</span> <span class="pre">contenido</span></code>), comentarios (<code class="code docutils literal notranslate"><span class="pre">comment</span> <span class="pre">contenido</span></code>)
o instrucciones de procesamiento (<code class="code docutils literal notranslate"><span class="pre">processing-instruction</span> <span class="pre">nombre</span>
<span class="pre">contenido</span></code>):</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="k">let</span><span class="w"> </span><span class="nv">$</span><span class="n">href</span><span class="w">    </span><span class="o">:=</span><span class="w"> </span><span class="s2">&quot;claustro.xsl&quot;</span>
<span class="k">return</span>
<span class="w">   </span><span class="p">(</span>
<span class="hll"><span class="w">      </span><span class="k">processing-instruction</span><span class="w"> </span><span class="nv">xml-stylesheet</span><span class="w"> </span><span class="p">{</span><span class="s1">&#39;type=&quot;text/xsl&quot; href=&quot;&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">href</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;&quot;&#39;</span><span class="p">},</span>
</span><span class="w">      </span><span class="k">element</span><span class="w"> </span><span class="p">{</span><span class="nf">name</span><span class="p">(/</span><span class="nt">*</span><span class="p">)}</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="nv">$</span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">         </span><span class="k">return</span>
<span class="w">            </span><span class="p">(</span>
<span class="hll"><span class="w">               </span><span class="k">comment</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;Profesor #&quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">i</span><span class="p">},</span>
</span><span class="w">               </span><span class="k">element</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="p">{(</span>
<span class="hll"><span class="w">                  </span><span class="k">attribute</span><span class="w"> </span><span class="nv">codigo</span><span class="w"> </span><span class="p">{</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@id</span><span class="p">},</span>
</span><span class="w">                  </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">nombre</span>
<span class="w">               </span><span class="p">)}</span>
<span class="w">            </span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">   </span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</section>
<section id="funciones-de-usuario">
<span id="xquery-user-functions"></span><h3><span class="section-number">4.1.4. </span>Funciones de usuario<a class="headerlink" href="#funciones-de-usuario" title="Enlace permanente a este encabezado">¶</a></h3>
<p><em>XQuery</em> permite, antes de la estructura <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr>, definir funciones de usuario
que piensen usarse luego en la estructura. Por ejemplo:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="c">(: funcion propia :)</span>
<span class="hll"><span class="kd">declare</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nf">local:declara-estilo</span><span class="p">(</span><span class="nv">$</span><span class="n">href</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
</span><span class="hll"><span class="w">   </span><span class="k">processing-instruction</span><span class="w"> </span><span class="nv">xml-stylesheet</span><span class="w"> </span><span class="p">{</span><span class="s1">&#39;type=&quot;text/xsl&quot; href=&quot;&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">href</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;&quot;&#39;</span><span class="p">}</span>
</span><span class="hll"><span class="p">};</span>
</span>
<span class="c">(: Como no necesitamos for ni let usamos directamente el contenido de &#39;return&#39; :)</span>
<span class="p">(</span>
<span class="hll"><span class="w">   </span><span class="nf">local:declara-estilo</span><span class="p">(</span><span class="s2">&quot;claustro.xsl&quot;</span><span class="p">),</span>
</span><span class="w">   </span><span class="k">element</span><span class="w"> </span><span class="p">{</span><span class="nf">name</span><span class="p">(/</span><span class="nt">*</span><span class="p">)}</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="nv">$</span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">      </span><span class="k">return</span>
<span class="w">         </span><span class="p">(</span>
<span class="w">            </span><span class="k">comment</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;Profesor #&quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">i</span><span class="p">},</span>
<span class="w">            </span><span class="k">element</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="p">{(</span>
<span class="w">               </span><span class="k">attribute</span><span class="w"> </span><span class="nv">codigo</span><span class="w"> </span><span class="p">{</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@id</span><span class="p">},</span>
<span class="w">               </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">nombre</span>
<span class="w">            </span><span class="p">)}</span>
<span class="w">         </span><span class="p">)</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="clausulas-adicionales">
<span id="xquery3"></span><h3><span class="section-number">4.1.5. </span>Cláusulas adicionales<a class="headerlink" href="#clausulas-adicionales" title="Enlace permanente a este encabezado">¶</a></h3>
<p><em>XQuery</em> 3 hizo algunos añadidos a la estructura original <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(FOR | LET | WINDOW)+ - WHERE? - ORDER BY? - GROUP BY? - COUNT? - RETURN
</pre></div>
</div>
<dl>
<dt><strong>COUNT</strong></dt><dd><p>permite definir un contador para las iteraciones:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="kp">xquery</span><span class="w"> </span><span class="kp">version</span><span class="w"> </span><span class="s2">&quot;3.0&quot;</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="s2">&quot;perro&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gato&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;jilguero&quot;</span><span class="p">)</span>
<span class="k">where</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s2">&quot;perro&quot;</span>
<span class="hll"><span class="k">count</span><span class="w"> </span><span class="nv">$</span><span class="n">n</span>
</span><span class="k">return</span>
<span class="w">   </span><span class="nv">$</span><span class="n">n</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot;. Mi mascota es un &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">$</span><span class="n">animal</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s2">&quot;.&quot;</span>
</pre></div>
</div>
</dd>
<dt><strong>GROUP BY</strong></dt><dd><p>como su homónimo en <abbr title="Strctured Query Language">SQL</abbr> permite agrupar los resultados según un determinado
criterio. Por ejemplo, esto sacaría un nuevo <code class="file docutils literal notranslate"><span class="pre">casillero.xml</span></code> en que los
profesores están agrupados por casilleros:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="kp">xquery</span><span class="w"> </span><span class="kp">version</span><span class="w"> </span><span class="s2">&quot;3.0&quot;</span><span class="p">;</span>

<span class="k">element</span><span class="w"> </span><span class="p">{</span><span class="nf">name</span><span class="p">(/</span><span class="nt">*</span><span class="p">)}</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">   </span><span class="k">let</span><span class="w"> </span><span class="nv">$</span><span class="n">depart</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">departamento</span>
<span class="w">   </span><span class="k">where</span><span class="w"> </span><span class="nv">$</span><span class="n">depart</span>
<span class="hll"><span class="w">   </span><span class="k">group by</span><span class="w"> </span><span class="nv">$</span><span class="n">depart</span>
</span><span class="w">   </span><span class="k">return</span>
<span class="w">      </span><span class="nt">&lt;departamento</span><span class="w"> </span><span class="nt">nombre</span><span class="o">=</span><span class="p">&quot;{</span><span class="nv">$</span><span class="n">depart</span><span class="p">}&quot;</span><span class="nt">&gt;</span>
<span class="l">         </span><span class="p">{</span><span class="nv">$</span><span class="n">p</span><span class="p">}</span>
<span class="l">      </span><span class="nt">&lt;/departamento&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Y si queremos incluir los sustitutos, podríamos echar mano de <em>XPath</em> 2:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="kp">xquery</span><span class="w"> </span><span class="kp">version</span><span class="w"> </span><span class="s2">&quot;3.0&quot;</span><span class="p">;</span>

<span class="k">element</span><span class="w"> </span><span class="p">{</span><span class="nf">name</span><span class="p">(/</span><span class="nt">*</span><span class="p">)}</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span>
<span class="w">   </span><span class="k">let</span><span class="w"> </span><span class="nv">$</span><span class="n">depart</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">departamento</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="nt">departamento</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">//</span><span class="nt">profesor</span><span class="p">[</span><span class="na">@id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">$</span><span class="n">p</span><span class="p">/</span><span class="na">@sustituye</span><span class="p">]/</span><span class="nt">departamento</span>
<span class="w">   </span><span class="k">where</span><span class="w"> </span><span class="nv">$</span><span class="n">depart</span>
<span class="hll"><span class="w">   </span><span class="k">group by</span><span class="w"> </span><span class="nv">$</span><span class="n">depart</span>
</span><span class="w">   </span><span class="k">return</span>
<span class="w">      </span><span class="nt">&lt;departamento</span><span class="w"> </span><span class="nt">nombre</span><span class="o">=</span><span class="p">&quot;{</span><span class="nv">$</span><span class="n">depart</span><span class="p">}&quot;</span><span class="nt">&gt;</span>
<span class="l">         </span><span class="p">{</span><span class="nv">$</span><span class="n">p</span><span class="p">}</span>
<span class="l">      </span><span class="nt">&lt;/departamento&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt><strong>WINDOW</strong></dt><dd><p>La cláusula (posiblemente la más compleja de las incorporadas) permite
agrupar datos al igual que <code class="docutils literal notranslate"><span class="pre">group</span> <span class="pre">by</span></code>, pero en vez de agrupar por valor,
agrupa por secuencias de ítems consecutivos. Por ejemplo, nos permitiría
agrupar los tres primeros ítems, luego los tres siguientes, y así sucesivamente
en grupos de tres.</p>
<p>Cada uno de estos grupos o rangos recibe el nombre de <em class="dfn">windows</em> y puede
haber de dos tipos:</p>
<ol class="arabic">
<li><p><em class="dfn">tumbling window</em>, que son rangos que nunca se solapan, esto es, que
no comparten ítems, por lo que el ítem que abre una ventana siempre tiene
que ser posterior al último que cierra la ventana anterior.</p>
<img alt="../_images/tumbling.png" src="../_images/tumbling.png" />
</li>
<li><p><em class="dfn">sliding window</em>, que son rangos solapables y, por tanto, dos
ventanas consecutivas podrań tener uno o más ítems comunes.</p>
<img alt="../_images/sliding.png" src="../_images/sliding.png" />
</li>
</ol>
<p>Para definir los límites de la ventana la sintaxis permite definir una
condición de comienzo y otra de fin. Por ejemplo:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>xquery version &quot;3.0&quot;;

for tumbling window $w in (1 to 10)
start when true()
end at $e when $e mod 3 = 0
return
   &quot;- &quot; || string-join($w, &quot;,&quot;)
</pre></div>
</div>
<p>establece una condición de comienzo que siempre que cumple y una de final en
los múltiplos de 3. Como las ventanas no pueden solaparse, lo que significa
que la ventana siguiente sólo puede comenzar después de que haya acabado la
anterior, el resultado es éste:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- 1,2,3
- 4,5,6
- 7,8,9
- 10
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Percátese de que puede asignar una variable al elemento (inicial o
final) de la ventana usando <code class="docutils literal notranslate"><span class="pre">at</span></code>, aunque puede hacerse elisión
(<code class="code docutils literal notranslate"><span class="pre">end</span> <span class="pre">$e</span></code> en vez de <code class="code docutils literal notranslate"><span class="pre">end</span> <span class="pre">at</span> <span class="pre">$e</span></code>).</p>
</div>
<p>A las condiciones podemos añadirle <code class="docutils literal notranslate"><span class="pre">only</span></code> para forzar a que se cumpla y, si
no es así, que no se llegue a constituir la ventana. Por tanto, el código:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>xquery version &quot;3.0&quot;;

for tumbling window $w in (1 to 10)
start when true()
only end at $e when $e mod 3 = 0
return
   &quot;- &quot; || string-join($w, &quot;,&quot;)
</pre></div>
</div>
<p>no llegará a constituir la última ventana anterior, ya que ésta no acababa en
un múltiplo de tres:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- 1,2,3
- 4,5,6
- 7,8,9
</pre></div>
</div>
<p>En cambio, si cambiamos el tipo de ventana…</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>xquery version &quot;3.0&quot;;

for sliding window $w in (1 to 10)
start when true()
only end at $e when $e mod 3 = 0
return
   &quot;- &quot; || string-join($w, &quot;,&quot;)
</pre></div>
</div>
<p>…ahora las ventanas se pueden solapar y cómo cualquier ítem es susceptible
de ser el comienzo de una el resultado es el siguiente:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- 1,2,3
- 2,3
- 3
- 4,5,6
- 5,6
- 6
- 7,8,9
- 8,9
- 9
- 10
</pre></div>
</div>
<p>Por último, existe también la posibilidad de asignar una variable al
siguiente elemento al que comienza o termina una ventana con la palabra
<code class="docutils literal notranslate"><span class="pre">next</span></code>:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span><span class="kp">xquery</span><span class="w"> </span><span class="kp">version</span><span class="w"> </span><span class="s2">&quot;3.0&quot;</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="k">tumbling</span><span class="w"> </span><span class="k">window</span><span class="w"> </span><span class="nv">$</span><span class="n">w</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="k">start</span><span class="w"> </span><span class="nt">at</span><span class="w"> </span><span class="nv">$</span><span class="n">i</span><span class="w"> </span><span class="k">next</span><span class="w"> </span><span class="nv">$</span><span class="n">i_next</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nv">$</span><span class="n">i_next</span><span class="w"> </span><span class="k">mod</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="k">only</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="nt">at</span><span class="w"> </span><span class="nv">$</span><span class="n">e</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nv">$</span><span class="n">e</span><span class="w"> </span><span class="k">mod</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="k">return</span>
<span class="w">   </span><span class="s2">&quot;- &quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nf">string-join</span><span class="p">(</span><span class="nv">$</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Este código provoca que sólo se tome como comienzo de ventana aquel ítem
cuyo siguiente en la secuencia sea múltiplo de dos. Como consecuencia, el
resultado es:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- 1,2,3
- 5,6
- 7,8,9
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La variable <code class="docutils literal notranslate"><span class="pre">$i</span></code> no la usamos para nada, por lo que podríamos
ahorrárnosla: <code class="code docutils literal notranslate"><span class="pre">start</span> <span class="pre">next</span> <span class="pre">$i_next</span> <span class="pre">when</span> <span class="pre">$i_next</span> <span class="pre">mod</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
</div>
</dd>
</dl>
</section>
<section id="actualizacion-de-datos">
<span id="xquery-update"></span><h3><span class="section-number">4.1.6. </span>Actualización de datos<a class="headerlink" href="#actualizacion-de-datos" title="Enlace permanente a este encabezado">¶</a></h3>
<p>Estrictamente <em>XQuery</em> permite la consulta de datos y la generación de una
salida en forma de nuevo <abbr title="eXtensible  Markup Language">XML</abbr>. Buscando la analogía con <abbr title="Strctured Query Language">SQL</abbr>, esto lo hace
equivalente a <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> que obtiene datos de una base de datos relacional y
genera una salida en forma de tabla. Sin embargo, el <abbr title="Data Manipulation Language">DML</abbr> de <abbr title="Strctured Query Language">SQL</abbr> lo
componen, además de <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>, <code class="docutils literal notranslate"><span class="pre">INSERT</span></code>, <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code> y <code class="docutils literal notranslate"><span class="pre">DELETE</span></code>, los cuales
permiten alterar el contenido. Para dotar a <em>XQuery</em> de la capacidad de
modificación que confieran estas tres sentencias, el <abbr title="World Wide Web Consortium">W3C</abbr> definió como
extensión al lenguaje (<a class="reference external" href="https://www.w3.org/TR/xquery-update-30">XQuery Update Facility 3.0</a>) cuatro nuevas expresiones que puede
incluirse en la cláusula <a class="reference internal" href="#xquery-return"><span class="std std-ref">RETURN</span></a> para modificar la fuente
original, en vez de generar una salida:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#xquery-insert"><span class="std std-ref">insert</span></a>, que permite añadir nodos.</p></li>
<li><p><a class="reference internal" href="#xquery-delete"><span class="std std-ref">delete</span></a>, que permite borrar nodos.</p></li>
<li><p><a class="reference internal" href="#xquery-replace"><span class="std std-ref">replace</span></a>, que permite reemplazar nodos</p></li>
<li><p><a class="reference internal" href="#xquery-rename"><span class="std std-ref">rename</span></a>, que permite renombrar nodos.</p></li>
</ul>
<section id="modificacion">
<h4><span class="section-number">4.1.6.1. </span>Modificación<a class="headerlink" href="#modificacion" title="Enlace permanente a este encabezado">¶</a></h4>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p>Estas sentencias de actualización de la fuente tienen sentido
cuando el origen <abbr title="eXtensible  Markup Language">XML</abbr> se utiliza como una base de datos, no como un archivo
independiente, por lo que es más pertienente practicarlas en la próxima
<a class="reference internal" href="../05.almacenamiento/index.html#lm-ut5"><span class="std std-ref">unidad dedicada al almacenamiento</span></a> y, en particular, en la
parte dedicada a <a class="reference internal" href="../05.almacenamiento/02.nativas.html#nativas"><span class="std std-ref">bases nativas</span></a>. Se incluye aquí su
explicación para no desgajarla del resto del lenguaje <em>XQuery</em>.</p>
</div>
<dl id="xquery-insert">
<dt><code class="docutils literal notranslate"><span class="pre">insert</span></code></dt><dd><p>Podemos insertar tanto elementos como atributos y especificando exactamente
dónde. Por ejemplo, la expresión:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>insert node &lt;foo/&gt; into //profesor[1]
</pre></div>
</div>
<p>Añade un elemento <em>foo</em> al final del primer profesor. Variantes a esto
podrían haber sido:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>insert node &lt;foo/&gt; as last into //profesor[1]
</pre></div>
</div>
<p>o, si lo queremos añadir al comienzo del elemento:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>insert node &lt;foo/&gt; as first into //profesor[1]
</pre></div>
</div>
<p>Para agregarlo en algún punto intermedio, tendríamos que echar mano de
<code class="docutils literal notranslate"><span class="pre">before</span></code> o <code class="docutils literal notranslate"><span class="pre">after</span></code>:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>insert node &lt;foo/&gt; after //profesor[1]/nombre
</pre></div>
</div>
<p>Obsérvese que estamos agregando un nodo y, en consecuencia, el destino debe
ser otro y no varios, ya que un nodo sólo puede añadirse en un lugar. Si
quisiéramos agregar un nodo <em>foo</em> a cada profesor, entonces tendríamos que
echar mano de la estructura <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr> explícita:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>for $p at $n in //profesor
return
   insert node &lt;foo&gt;{$n}&lt;/foo&gt; after //profesor[1]/nombre
</pre></div>
</div>
<p>Hemos complicado un poco la inserción para que se vea que estamos usando un
<a class="reference internal" href="#xquery-const-directo"><span class="std std-ref">constructor directo</span></a> para el elemento <em>foo</em>. De
hecho, también podríamos haber usado un <a class="reference internal" href="#xquery-const-eval"><span class="std std-ref">constructor evaluado</span></a>:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>for $p at $n in //profesor
return
   insert node element foo {$n} after //profesor[1]/nombre
</pre></div>
</div>
<p>En realidad, es posible insertar una secuencia de nodos:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>insert node (&lt;foo/&gt;, &lt;bar/&gt;) into //profesor[1]
</pre></div>
</div>
<p>Y también atributos, aunque usando un <em>constructor evaluado</em>:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>insert node attribute foo {&quot;bar&quot;} into //profesor[1]
</pre></div>
</div>
</dd>
</dl>
<dl id="xquery-delete">
<dt><code class="docutils literal notranslate"><span class="pre">delete</span></code></dt><dd><p>Borra la secuencia de nodos que se exprese como argumento. Por ejemplo,
la siguiente expresión elimina el atributo casillero de todos los profesores
que lo tengan.</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>delete node //profesor/@casillero
</pre></div>
</div>
</dd>
</dl>
<dl id="xquery-replace">
<dt><code class="docutils literal notranslate"><span class="pre">replace</span></code></dt><dd><p>Remplaza el nodo indicado por otro que se le facilite:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>replace node //profesor[1]/apelativo with &lt;apelativo&gt;Luisito&lt;/apelativo&gt;
</pre></div>
</div>
<p>Aunque en este caso, como nuestra intención era cambiar el contenido y no el
nombre del nodo, quizás habría sido mejor:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>replace node //profesor[1]/apelativo/text() with &quot;Luisito&quot;
</pre></div>
</div>
<p>Por supuesto, también podemos cambiar atributos:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>replace node //profesor[1]/@id with attribute id {&quot;p22&quot;}
</pre></div>
</div>
</dd>
</dl>
<dl id="xquery-rename">
<dt><code class="docutils literal notranslate"><span class="pre">rename</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">replace</span></code> sustituye por completo el nodo, lo cual incluye todos sus
descendientes. <code class="docutils literal notranslate"><span class="pre">rename</span></code>, en cambio, nos permite cambiar el nombre del nodo
sin anterar en absoluto su contenido:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>rename //profesor[1]/apelativo as &quot;apodo&quot;
</pre></div>
</div>
<p>Y, de nuevo, también permite cambiar el nombre de un atributo:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>rename //profesor[1]/@id as &quot;codigo&quot;
</pre></div>
</div>
</dd>
</dl>
</section>
<section id="modificacion-en-memoria">
<h4><span class="section-number">4.1.6.2. </span>Modificación en memoria<a class="headerlink" href="#modificacion-en-memoria" title="Enlace permanente a este encabezado">¶</a></h4>
<p>Los ejemplos anteriores sirven todos para modificar el documento original. Ahora
bien, supongamos que queremos generar una salida que es muy parecida al archivo
original. Con las técnicas vistas antes de este <a class="reference internal" href="#xquery-update"><span class="std std-ref">epígrafe de actualización</span></a>, esa generación a pesar de ser una pequeña variante del
original, nos supondría bastante esfuerzo. Por ese motivo, <em>XQuery</em> permite la
posibilidad de copiar parte del documento original en memoria, hacer los cambios
usando las técnicas arriba vistas y, finalmente, volcar en la salida la copia.</p>
<p>Por ejemplo, imaginemos que quisiéramos generar una salida del documento de
casilleros exactamente igual al original con la única diferencia de que el
elemento <em>casillero</em> para a ser un atributo. El ejercicio podríamos realizarlo
así:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>element {fn:local-name(/*)} {(
    /*/@*,
    for $p in //profesor
    return
<span class="hll">        (: Estructura copy-modify-return :)
</span><span class="hll">        copy $p_mod := $p
</span><span class="hll">        modify (
</span><span class="hll">            insert node attribute departamento {$p/departamento} into $p_mod,
</span><span class="hll">            delete node $p_mod/departamento
</span><span class="hll">        )
</span>        return $p_mod
)}
</pre></div>
</div>
<p>Esto es:</p>
<ul class="simple">
<li><p>Creamos un elemento raíz con el mismo y nombre y con los mismos atributos.</p></li>
<li><p>Recorremos cada uno de los nodos profesor (<code class="docutils literal notranslate"><span class="pre">$p</span></code>).</p></li>
<li><p>En vez de volcarlo directamente, lo cual provocaría que obtuviéramos como
salida la misma entrada, echamos mano de la estructura <code class="docutils literal notranslate"><span class="pre">copy</span></code>-<code class="docutils literal notranslate"><span class="pre">modify</span></code>- <code class="docutils literal notranslate"><span class="pre">return</span></code>:</p>
<ul>
<li><p>Con <code class="docutils literal notranslate"><span class="pre">copy</span></code> copiamos el elemento en una variable (<code class="docutils literal notranslate"><span class="pre">$p_mod</span></code>).</p></li>
<li><p>Con <code class="docutils literal notranslate"><span class="pre">modify</span></code> modificamos la copia. Como tenemos que hacer dos cambios,
utilizamos una secuencia de dos ítems, el primero el atributo <em>departamento</em>
a la copia y el segundo borra el ya inútil elemento <em>departamento</em>.</p></li>
<li><p>Con <code class="docutils literal notranslate"><span class="pre">return</span></code> devolvemos el nodo modificado.</p></li>
</ul>
</li>
</ul>
<p>Para no enmarañar el ejemplo, hemos evitado tener en cuenta que hay
profesores sin departamento a los que, por tanto, no hay que hacerle ninguna
modificación. Esto, no obstante, no es algo que no podamos resolver con
<a class="reference internal" href="../03.consulta/01.xpath.html#xpath2-const-if"><span class="std std-ref">if</span></a>:</p>
<div class="highlight-xquery notranslate"><div class="highlight"><pre><span></span>element {fn:local-name(/*)} {(
    /*/@*,
    for $p in //profesor
    return
<span class="hll">        copy $p_mod := $p
</span><span class="hll">        modify (
</span><span class="hll">            if ($p/departamento) then (
</span><span class="hll">                insert node attribute departamento {$p/departamento} into $p_mod,
</span><span class="hll">                delete node $p_mod/departamento
</span><span class="hll">            ) else ( (: No hay modificación alguna :) )
</span><span class="hll">        )
</span><span class="hll">        return $p_mod
</span>)}
</pre></div>
</div>
</section>
</section>
</section>
<section id="xslt">
<h2><span class="section-number">4.2. </span><abbr title="eXtensible Stylesheet Language Transformations">XSLT</abbr><a class="headerlink" href="#xslt" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Un estudio consistente de este lenguaje de transformación es demasiado amplio
para la escasa carga lectiva del módulo, pero pertinente a la vista del
currículo. Por ello, trasladamos su desarrollo al <a class="reference internal" href="../98.apendices/41.xslt.html#xslt"><span class="std std-ref">apendice correspondiente</span></a>.</p>
</section>
<section id="ejercicios-propuestos">
<h2><span class="section-number">4.3. </span>Ejercicios propuestos<a class="headerlink" href="#ejercicios-propuestos" title="Enlace permanente a este encabezado">¶</a></h2>
<ol class="arabic">
<li><p>A partir del <abbr title="eXtensible  Markup Language">XML</abbr> sobre facturas obtenga un lista de clientes en que se
exprese para cada uno de ellos su nombre y la cantidad de facturas emitidas
a su nombre. Por ejemplo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Clientes del negocio:
   - Perico de los Palotes: 3 facturas.
   - Mariquilla de la O: 2 facturas.
</pre></div>
</div>
<p class="sol-oculta"><a class="reference download internal" download="" href="../_downloads/a7d6e8d06892485a6d0f5a5b96627bd5/facturas-01.xq"><code class="xref download docutils literal notranslate"><span class="pre">Solución</span> <span class="pre">propuesta</span></code></a>.</p>
</li>
<li><p>A partir del <abbr title="eXtensible  Markup Language">XML</abbr> sobre facturas obtenga un listado de facturas en
que se expresa de cada una de ellas el código y el nombre del cliente al que
se facturó. Por ejemplo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Listado de facturas:
   - f01: Perico de los Palotes
   - f02: Mariquilla de la O
</pre></div>
</div>
<p class="sol-oculta"><a class="reference download internal" download="" href="../_downloads/4acf48b89b861e2c93122fb7051b2842/facturas-02.xq"><code class="xref download docutils literal notranslate"><span class="pre">Solución</span> <span class="pre">propuesta</span></code></a>.</p>
</li>
<li><p>A partir del <abbr title="eXtensible  Markup Language">XML</abbr> sobre facturas obtenga un listado de facturas
en que se exprese de cada una de ellas el código y el coste total. Por
ejemplo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Coste de las facturas:
   - f01: 1.7€
   - f02: 5.2€
</pre></div>
</div>
<div class="sol-oculta line-block">
<div class="line"><a class="reference download internal" download="" href="../_downloads/6da16ef0a5477665626b660764c83c01/facturas-04.xq"><code class="xref download docutils literal notranslate"><span class="pre">Solución</span> <span class="pre">propuesta</span> <span class="pre">1</span></code></a>.</div>
<div class="line"><a class="reference download internal" download="" href="../_downloads/5e9d6e4a9c299d6ec1d2c3a4a9a714aa/facturas-04b.xq"><code class="xref download docutils literal notranslate"><span class="pre">Solución</span> <span class="pre">propuesta</span> <span class="pre">2</span></code></a> (usando <em>XPath</em> 1.0).</div>
</div>
</li>
<li><p>Tome el <abbr title="eXtensible  Markup Language">XML</abbr> sobre facturas y componga otro similar en que
las facturas, en vez de estar aparte, sean hijas del cliente
a nombre del que se han emitido.</p>
<div class="sol-oculta line-block">
<div class="line"><a class="reference download internal" download="" href="../_downloads/ff1201c0f78f6ac846331f319dd2fc3c/facturas-05.xq"><code class="xref download docutils literal notranslate"><span class="pre">Solución</span> <span class="pre">propuesta</span> <span class="pre">1</span></code></a> (sin modificaciones en memoria).</div>
<div class="line"><a class="reference download internal" download="" href="../_downloads/f50cbc6f48a804e5cf9fade9de69a066/facturas-05b.xq"><code class="xref download docutils literal notranslate"><span class="pre">Solución</span> <span class="pre">propuesta</span> <span class="pre">2</span></code></a> (con modificaciones en memoria).</div>
</div>
</li>
</ol>
<p class="rubric">Nota al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>Porque estas son las cláusulas de las que podía constar la estructura. La
versión <strong>3</strong> añadió otras cláusulas adicionales.</p>
</aside>
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>En realidad, se puede escribir conjunto mayor de expresiones de las
validas para <em>XPath</em>, ya que <em>XQuery</em> soportas cláusulas inexistentes en
<em>XPath</em> como la propia estructura <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr> o los <a class="reference internal" href="#xquery-output-xml"><span class="std std-ref">constructores para
generar una salida XML</span></a>.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
        <p class="logo"><a href="../index.html" title="index">
          <img class="logo" src="../_static/logo.png" alt="Logo"/>
        </a></p><div class="sphinx-toc sphinxlocaltoc">
    <h3><a href="../index.html">Page contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">4. Transformación de datos</a><ul>
<li><a class="reference internal" href="#xquery">4.1. XQuery</a><ul>
<li><a class="reference internal" href="#procesadores">4.1.1. Procesadores</a></li>
<li><a class="reference internal" href="#flwor-basico">4.1.2. <abbr title="For, Let, Where, Order by, Return">FLWOR</abbr> básico</a></li>
<li><a class="reference internal" href="#construccion-de-salida-xml">4.1.3. Construcción de salida <abbr title="eXtensible  Markup Language">XML</abbr></a></li>
<li><a class="reference internal" href="#funciones-de-usuario">4.1.4. Funciones de usuario</a></li>
<li><a class="reference internal" href="#clausulas-adicionales">4.1.5. Cláusulas adicionales</a></li>
<li><a class="reference internal" href="#actualizacion-de-datos">4.1.6. Actualización de datos</a><ul>
<li><a class="reference internal" href="#modificacion">4.1.6.1. Modificación</a></li>
<li><a class="reference internal" href="#modificacion-en-memoria">4.1.6.2. Modificación en memoria</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#xslt">4.2. <abbr title="eXtensible Stylesheet Language Transformations">XSLT</abbr></a></li>
<li><a class="reference internal" href="#ejercicios-propuestos">4.3. Ejercicios propuestos</a></li>
</ul>
</li>
</ul>

  </div>
  <div class="sphinxprev">
    <h4>Previous page</h4>
    <p class="topless"><a href="../03.consulta/02.jsonpath.html"
                          title="Previous page">&larr; <span class="section-number">3.2. </span><abbr title="JavaScript Object Notation">JSON</abbr>Path</a></p>
  </div>
  <div class="sphinxnext">
    <h4>Next page</h4>
    <p class="topless"><a href="../05.almacenamiento/index.html"
                          title="Next page">&rarr; <span class="section-number">5. </span>Almacenamiento</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/04.transformacion/index.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="../05.almacenamiento/index.html" title="5. Almacenamiento"
             >siguiente</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="../03.consulta/02.jsonpath.html" title="3.2. JSONPath"
             >anterior</a> &nbsp; &nbsp;</li>
    <li><a href="../index.html">documentación de Lenguajes de Marcas - rolling</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4. </span>Transformación de datos</a></li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2023-2023, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>