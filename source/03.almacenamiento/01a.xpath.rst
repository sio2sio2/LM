.. _xpath:

*****
XPath
*****
En muchas de las operaciones que se hacen con un documento |XML|, como extraer
información o escribir reglas para su transformación es necesario referirse a
nodos o conjuntos de nodos. :dfn:`XPath` es un sintaxis estándar para la
selección de uno o varios componentes (nodos, atributos, etc.) dentro de un
documento |XML|.

*XPath* es, pues, un estandar del |W3C| para seleccionar con qué nodos de un
documento |XML| se desea operar para cuya operación posterior se requerirá el
uso de otra herramienta como :ref:`XQuery`, :ref:`XSLT` o alguna biblioteca  de
programas de propósito general. Es, por tanto, una herramienta que no tiene
sentido utilizar aislada.

.. caution:: *XPath* no es el único lenguaje para esta tarea. En |HTML| (que
   no es |XML|, pero tiene bastantes semejanzas) es muy común usar para la
   selección de nodos los :ref:`selectores CSS <css-selectors>`, diseñados en
   principio para definir su estilo (o sea, su aspecto). A pesar de nacer para
   documentos |HTML|, los *selectores CSS* son perfectamente válidos para
   identificar nodos |XML|, por lo que son una alternativa muy utilizado. Por
   ejemplo, Javascript_ los soporta para la selección de nodos en general (véase
   `document.querySelectorAll
   <https://developer.mozilla.org/es/docs/Web/API/Document/querySelectorAll>`_),
   en vez de *XPath*, a pesar de que existe  la función `document.evaluate
   <https://developer.mozilla.org/es/docs/Web/JavaScript/Introduction_to_using_XPath_in_JavaScript>`_,
   que permite usar *XPath*.

El nombre de la tecnología deriva de la fusión de |XML| y la palabra inglesa
*path*, que en un sistema de archivo es la manera de indicar la ruta que hay que
seguir para llegar a un determinado archivo. La analogía no es gratuita, puesto
que en el caso de los sistemas de archivos se habla del árbol de directorios, de
la misma manera que en un documento |XML| hay un :ref:`árbol de nodos
<xml-jerarq>`.

Desde su creación en 1999, *XPath* se ha ido actualizando con distintas
**versiones**:

.. rst-class:: simple

`Versión 1 <https://www.w3.org/TR/xpath-10/>`_,
  que apareció en el año 1999, y es universalmente soportada. Es la versión que
  soporta `libxml <http://xmlsoft.org/>`_, la librería que utiliza
  :command:`xmlstarlet`.

`Versión 2 <https://www.w3.org/TR/xpath-20/>`_,
  que apareció en 2007, e introduce mejoras muy significativas. No todo el
  software soporta esta especificación.

`Versión 3 <https://www.w3.org/TR/xpath-30/>`_,
  que apareció en 2014. El cambio respecto a la versión anterior, `no es tan
  significativo <https://en.wikipedia.org/wiki/XPath_3>`_ como el que se produjo
  entre la **1** y la **2**.  En el mundo del software libre soportan esta
  versión la librería `Saxon
  <http://saxon.sourceforge.net/saxon7.7/api-guide.html>`_ para `Java
  <https://www.java.com/>`_ y `Xerces <http://xerces.apache.org/>`_, que tiene
  versión para `C++ <https://es.wikipedia.org/wiki/C%2B%2B>`_. En la |CLI| de
  Linux puede usarse a través de algunos programas de *software* libre:

  + `xqilla <http://xqilla.sourceforge.net/HomePage>`_, que aunque tiene paquete
    en *Debian*, desgraciadamente no está disponible para *Bookworm*, por
    `problemas de compilación con g++-11
    <https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=984418>`_.

  + xidel_, que no tiene paquete oficial, pero puede descargarse de su página
    oficial.

`Versión 3.1 <https://www.w3.org/TR/xpath-31/>`_,
  publicada en 2017, que añade soporte para dos tipos de datos nuevos, la
  secuencia y el mapa, lo que posibilita que el lenguaje sea apto para consultar
  también documentos |JSON|.

.. seealso:: El |W3C| mantiene una `página que enumera todas las versiones
   <https://www.w3.org/TR/xpath/>`_. Para una exhaustiva comparación entre las
   versiones **1.0** y **2.0** se encuentra `en este documento
   <http://www.mulberrytech.com/papers/XPath-2-0-User-Grp-HTML/contents.html>`_
   y para una comparación más sucinta `este artículo en la web de Microsoft
   <https://learn.microsoft.com/en-us/archive/msdn-magazine/2003/january/the-xml-files-introducing-xpath-2-0>`_.

En estos apuntes desarrollaremos primero la norma de *XPath* 1.0 (por su amplio
soporte) y expondremos luego cuáles son los cambios y ampliaciones que presenta
*XPath* 2.0.

.. _xpath-procesadores:

Procesadores
************
Como en unidades anteriores, antes de entrar en profundidad en el asunto, es
conveniente conocer qué herramientas tenemos para procesar nuestras expresiones
*Xpath* tenemos muchas alternativas. Hay muchas entre las que señalaremos:

* `XPather  <http://xpather.com/>`_, que permite evaluar online expresiones
  *XPath* 2.0.
* `Visual Studio Code`_ con la extensión `XPath Tester
  <https://marketplace.visualstudio.com/items?itemName=creinbacher.xpathtester>`_
  permite evaluar expresiones *XPath* 1.0. Para evaluar expresiones, basta con
  pulsar :kbd:`Ctrl+Shift+P` y buscar *XPath* para que accedamos al cuadro de
  diálogo que nos permite hacer evaluaciones.
* El paquete :deb:`xmlstarlet`, cuyo paquete homónimo permite utilizar
  expresiones *XPath* 1.0 tanto para seleccionar información del |XML| original,
  como para modificarlo.
* El programa xidel_, que soporta XPath 3.0.

Expondremos estos dos últimos programas de línea de comandos, porque son los
únicos que requieren alguna explicación sobre su funcionamiento:

.. caution:: A estas alturas aún, la lectura completa del siguiente epígrafe es
   empachante y nada recomendable. Nos basta con saber cómo evaluar las
   expresiones *XPath* que se van introduciendo gradualmente, con lo que nos sobra con
   saber cómo usar :ref:`xidel <xpath-xidel>`, si necesitamos probar expresiones
   validas únicas en *XPath* 2.0, o manejar la extensión de `Visual Studio
   Code`_ que no requiere gran pericia.

.. _xpath-xidel:

:program:`Xidel`
================
La principal ventaja de usarlo frente a :ref:`xmlstarlet <xpath-xidel>` es que
podremos probar expresiones *XPath* 2.0 ó 3.0.

Para comprobar nuestras expresiones *XPath* podemos usarlo de dos modos
distintos:

* Si el resultado es texto:

  .. code-block:: console

     $ xidel -s -e '//profesor[1]/@id' casilleros.xml
     p1

  donde ":kbd:`-s`" evita mensajes de información innecesarios, y ":kbd:`-e`" introduce
  la expresión *XPath*.

* Si el resultado es un nodo o un conjunto de nodos, es necesario añadir
  :kbd:`--printed-node-format=xml`:

  .. code-block:: console

     $ xidel -s --printed-node-format=xml -e '//profesor/apelativo' casilleros.xml

.. _xpath-xmlstarlet:

:program:`XMLStarlet`
=====================
Con este programa podemos usar *XPath* tanto para seleccionar datos como para
introducir modificaciones al |XML| original. Lo segundo no nos interesa
demasiado, pero por completar la información sobre la orden incluiremos las
posibilidades que brinda.

Selección
---------
Para lograrlo es necesario usar el comando ``sel``, seguido de la opción ``-t``, y
la acción que se quiere realizar a continuación, que puede ser:

:code:`-v <expresión-xpath>`
   Muestra el valor de lo seleccionado mediante la expresión. Se debe estar
   opción cuuando el resultado de la expresión es un valor escalar: un único
   atributo, un nodo que contiene texto o el evaluación de un función o una
   operación. Por ejemplo::

      $ xmlstarlet sel -t -v '//profesor[1]/@id' -n casilleros.xml
      p1

   .. note:: Se ha añadido la opción ``-n`` para añadir un cambio de línea al
      final del resultado.

:code:`-c <expresion-path>`
   Copia el nodo seleccionado, por tanto deberá usarse cuando el resultado de
   nuestra selección es un nodo elemento o un conjunto de nodos elemento. Por
   ejemplo, lo siguiente devuelve todos los nodos *apelativo*::

      $ xmlstarlet sel -t -c '//profesor/apelativo' -n casilleros.xml
      <apelativo>Pepe</apelativo><apelativo>Paco</apelativo><apelativo>Mari</apelativo>

:code:`-m <expresión-path>`
   Selecciona un nodo o un conjunto de nodos para seguir trabajando sobre
   ellos. Por tanto, requerirá que luego se use ``-v`` o ``-c``. Por ejemplo::

      $ xmlstarlet sel -t -m '//profesor/apelativo' -v '.' casilleros.xml
      PepePacoMari

   En este caso, habría sido fundamental usar ``-n``::

      $ xmlstarlet sel -t -m '//profesor/apelativo' -v '.' -n casilleros.xml
      Pepe
      Paco
      Mari

.. note:: :command:`xmlstarlet` es capaz de devolvernos el código |XSLT|
   equivalente a nuestra selección añadiendo tras ``sel`` la opción ``-C``.

Edición
-------
En este caso, debe usarse ``ed``, una acción y el uso de expresiones *XPath*:

:code:`-d <expresion-xpath>`
   Borra los nodos que selecciona la expresión::

      $ xmlstarlet ed -d '//profesor[last()]' casilleros.xml

   Esta expresión elimnina el último de los profesores.
   
:code:`-u <expresion-xpath> -v valor`
   Actualiza el valor del nodo o nodos seleccionados::

      $ xmlstarlet ed -u '//profesor[1]/apelativo' -v "Manolo" casilleros.xml

:code:`-i <expresión-xpath> -t (elem|text|attr) -n <nombre> -v <valor>`
   Permite insertar antes del nodo seleccionado (o los nodos) un nodo de tipo
   elemento, texto o atributo del nombre y valor referidos. Se deben hacer
   varias puntualizaciones:

   * Los nodos de texto no tienen nombre, así que da igual el nombre que se les
     dé.

   * El valor sólo puede ser texto, así que, directamente, sólo se pueden crear
     nodos elemento que contienen texto.

   * Si se quiere crear nodos elemento que tienen atributos o contienen otros
     nodos elemento, entonces hay que componer varias acciones.

   Por ejemplo, esto añadiría un nuevo apelativo al primer profesor::

    $ xmlstarlet ed -i '//profesor[1]/nombre' -t elem -n "apelativo" -v "Pancho" casilleros.xml

:code:`-a <expresión-xpath> -t (elem|text|attr) -n nombre -v valor`
   Como  ``-i`` pero añade el nodo después, no antes. Por ejemplo::

    $ xmlstarlet ed -a '//profesor[1]/apelativo[last()]' -t elem -n "apelativo" -v "Pancho" casilleros.xml

:code:`-s <expresión-xpath> -t (elemen|text|attr) -n nombre -v valor`
   Añade el nuevo elemento como último elemento del elemento seleccionado::

    $ xmlstarlet ed -s '//profesor[2]/nombre' -t text -n foo -v " María" casilleros.xml

.. note:: Las transformaciones que podemos hacer de este modo son bastante
   limitadas. Un mecanismo más apropiado para realizarlas es usar :ref:`XSLT
   <xslt>`.

Sintaxis
********
Una expresión *XPath* es, simplemente, una expresión evaluable que devuelve un
resultado. Por lo general, dentro de esta expresión se refieron nodos del |XML|,
pero no necesariamente. Ésta es una expresión *XPath* perfectamente válida:

.. code-block:: xquery

   1 = 1

¿Es **1**  igual a **1**?  Al ser una tautología, la respuesta es obviamente
verdadera, así que el resultado de es expresión será ``true``. Cuando
involucramos nodos en la expresión:

.. code-block:: xquery

   /nodo1/nodo2/nodo3

se advierte mejor la analogía entre *XPath* y las rutas de archivos. En este
caso, la evaluación de expresión devolverá todos los *nodo3* incluídos dentro de
los *nodo2* incluidos dentro del *nodo1*.  O sea, lo mismo que devolvería una
ruta de archivos con la salvedad de que los directorios son únicos y no se
podría devolver varios.

Traigamos el ejemplo del claustro de profesores para ilustrar las rutas que
expresemos a continuación:

.. dropdown:: XML de casilleros

   .. literalinclude:: ../02.validacion/files/casilleros_v2.xml
      :language: xml

En este caso, la expresión:

.. code-block:: xquery

   /claustro

representa el nodo raíz *claustro*, mientras que la expresión:

.. code-block:: xquery

   /claustro/profesor

representa todos los nodos *profesor* que son hijos del *claustro*.  Es posible
también hacer referencia a descendientes no directos como en:

.. code-block:: xquery

   /claustro//nombre

en que seleccionamos todos los nodos *nombre* que son descendientes de claustro.
Para este caso particular, obtenemos los nombres de todos profesores que
pertenecen al claustro. Otro ejemplo podría ser:

.. code-block:: xquery

   //profesor

Del mismo modo que en las rutas de archivos existen rutas relativas, en las
rutas *XPath* también existen, y del mismo modo que puede surgir la necesidad de
seleccionar un directorio o archivo cuando nos encontramos trabajando en otro
directorio, es posible que necesitemos hacer referencia a otros nodos, cuando
nos encontramos procesando un determinado nodo. Para las rutas relativas, como
en el caso de los archivos, se usa el punto (``.``), que significa este nodo, y
dos puntos seguidos (``..``), que significan el nodo padre. Así pues, si
estuviésemos procesando un determinado nodo *profesor*, la ruta:

.. code-block:: xquery

   ./nombre

o, simplemente:

.. code-block:: xquery

   nombre

representaría el nodo *nombre* de ese profesor; mientras que, si procesando el
nodo *apelativo* de un procesor, hacemos referencia a:

.. code-block:: xquery

   ../nombre

haremos referencia al nombre del profesor cuyo nodo estuviéramos procesando. En
realidad la expresión del nodo es algo más complicada que indicar simplemente su
nombre como introdujimos antes:

.. code-block:: xquery

   /nodo1/nodo2/nodo3

Cada paso de la ruta tiene, en realidad, la siguiente estructura completa:

.. code-block:: xquery

   eje::filtro[predicado]

.. warning:: Antes de proseguir es importante hacer una aclaración
   terminológica. Hasta ahora es posible que hubiéramos tratado los términos
   "*nodo*" y "*elemento*" como sinónimos. Pero ello no es así: un
   :dfn:`elemento`, en realidad, es un tipo de *nodo* llamado *nodo elemento*.
   *Nodo* es un término más general que engloba también otros tipos de nodos:
   los *atributos*, que son *nodos atributo*; los *comentarios*, que son *nodos
   comentario*; el texto, que son *nodos texto*, etc.

Filtros
=======
El :dfn:`filtro` es aquella parte de la ruta *XPath* que expresa qué nodo o nodos
quieren referirse con tal ruta. Puede ser:

**QName**
   Es el nombre del nodo. Por ejemplo:

   .. code-block:: xquery

      /claustro

   selecciona el nodo *claustro*. Puede usarse un asterisco ("*") para indicar
   cualquier nodo que sea elemento. Por ejemplo:

   .. code-block:: xquery

      /claustro/profesor[1]/*

   selecciona los elementos *apelativo*, *nombre*, *apellidos* y *departamento*
   hijos del primer profesor.

**text()**
   Selecciona los nodos de texto. Por ejemplo:

   .. code-block:: xquery

      /claustro/profesor[1]/nombre/text()

   devuelve exclusivamente la cadena "*José*", mientras que la expresión:

   .. code-block:: xquery

      /claustro/profesor[1]/nombre

   devuelve el nodo *nombre*, esto es:

   .. code-block:: xml

      <nombre>José</nombre>


   .. note:: Nótese que a efectos de su definición gramatical este nodo:

      .. code-block:: xml

         <profesor id="p1" sexo="hombre">
            <apelativo>Pepe</apelativo>
            <nombre>José</nombre>
            <apellidos>Suárez Lantilla</apellidos>
            <departamento>&ING;</departamento>
         </profesor>

      y este otro:

      .. code-block:: xml

         <profesor id="p1" sexo="hombre"><apelativo>Pepe</apelativo><nombre>José</nombre><apellidos>Suárez Lantilla</apellidos><departamento>&ING;</departamento></profesor>

      son equivalentes: un nodo *profesor* que contiene cuatro nodos elemento:
      *apelativo*, *nombre*, *apellidos* y *departamento*. En cambio, para *XPath*
      la primera expresión de *profesor* contiene nodos texto entre los
      nodo elementos, cada uno de los cuales contiene, siemplemente, caracteres
      de espaciado.

**node()**
   Todos los nodos, sean del tipo que sean. Por ejemplo:

   .. code-block:: xquery

      /claustro/node()

   selecciona todos los nodo *profesor* y todos los nodos texto hijo,
   consecuencia de haber sangrado tan bien el documento.

   .. note:: En cambio:

      .. code-block:: xquery

         /claustro/*

      selecciona exclusiamente los nodos *profesor*.

**comment()**
   Todos los nodos que sean comentarios:

   .. code-block:: xquery

      /claustro/comment()

**@atributo**
   Selecciona el atributo con el nombre expresado. Por ejemplo:

   .. code-block:: xquery

      /claustro/profesor/@sexo

   refiero los sexos de todos los profesores.

**processing-instruction()**
   Todas las instrucciones de procesamiento. Por ejemplo::

   .. code-block:: xquery

      '//procesing-instruction()'

   selecciona todas las instrucciones de procesamiento del documento.

**processing-instruction(destino)**
   Todas las instrucciones de procesamiento cuyo destino sea el indicado. El
   :dfn:`destino` es la palabra adyacente al signo "?".

.. note:: Obsérvese que estas expresiones responden a cuáles son los siete tipos de
   nodos que el modelo de datos de *XPath* define:

   #. Nodo de documento (o nodo raíz)
   #. Nodo elemento.
   #. Nodo texto.
   #. Nodo atributo.
   #. Nodo de espacio de nombres.
   #. Nodo de instrucción de procesamiento.
   #. Nodo comentario.

   De entre estos siete tipos, dos (los nodos texto y los nodos atributo) pueden
   a su ver estar tipados de distinta forma (ser cadenas, ser números, etc.).
   Más adelaten profundizaremos en ello.

*XPath* permite **agregar rutas** de manera que los nodos seleccionados sean la
unión de los nodos que seleccionan las distintas rutas. Para ello, usa el
operador ":kbd:`|`":

.. code-block:: xquery

   //profesor/apelativo | //profesor/nombre

selecciona todos los nodos *apelativo* y *nombre* de todos los profesores.

Ejes
====
El :dfn:`eje` es la parte de la ruta *XPath* que determina el sentido que se
tomará al interpretar la siguiente parte de la ruta. Recordemos que, si nos
encontramos procesando un nodo y queremos referirnos a otro, podemos buscar
entre sus descendientes, entre sus ascendientes o entre sus hermanos.

.. table:: **Ejes en XPath**
   :class: tb-eje

   +-------------+------------+-------------+----------------------------------------------+------------------------------------------+
   | Sentido     | Nombre     | Abreviatura | Ejemplo                                      | Descripción                              |
   +=============+============+=============+==============================================+==========================================+
   | Descendente | child      |             | | /claustro/profesor                         | Selecciona hijos.                        |
   |             |            |             | | /claustro/child::profesor                  |                                          |
   |             +------------+-------------+----------------------------------------------+------------------------------------------+
   |             | descendent | /           | | /claustro//apelativo                       | Selecciona descendientes.                |
   |             |            |             | | /claustro/descendent::apelativo            |                                          |
   |             +------------+-------------+----------------------------------------------+------------------------------------------+
   |             | self       | .           | | /claustro/.                                | Selecciona el propio nodo.               |
   |             |            |             | | /claustro//self::*                         |                                          |
   |             +------------+-------------+----------------------------------------------+------------------------------------------+
   |             | descendent-or-self       | /claustro/descendent-or-self::*              | Selecciona descendientes o el propio nodo|
   |             +--------------------------+----------------------------------------------+------------------------------------------+
   |             | following-sibling        | //profesor[1]/following-sibling::profesor    | Selecciona los hermanos posteriores      |
   |             +--------------------------+----------------------------------------------+------------------------------------------+
   |             | following                | //profesor[1]/following::*                   | Selecciona los nodos posteriores         |
   |             +------------+-------------+----------------------------------------------+------------------------------------------+
   |             | attribute  | @           | | //profesor/\@sexo                          | Selecciona atributo (puede usarse        |
   |             |            |             | | //profesor/attribute::sexo                 | ``@*``)                                  |
   +-------------+------------+-------------+----------------------------------------------+------------------------------------------+
   | Ascendente  | parent     | \.\.        | | //profesor[1]/apelativo/..                 | Selecciona el nodo padre.                |
   |             |            |             | | //profesor[1]/apelativo/parent::*          |                                          |
   |             +------------+-------------+----------------------------------------------+------------------------------------------+
   |             | ancestor                 | | //profesor[1]/apelativo/ancestor::*        | Selecciona ascendientes.                 |
   |             +--------------------------+----------------------------------------------+------------------------------------------+
   |             | ancestor-or-self         | //profesor[1]/apelativo/ancestor-or-self::*  | Seleccioa ascendientes o el propio nodo  |
   |             +--------------------------+----------------------------------------------+------------------------------------------+
   |             | preceding                | //profesor[2]/nombre/preceding::nombre       | Selecciona nodos anteriores              |
   |             +--------------------------+----------------------------------------------+------------------------------------------+
   |             | preceding-sibling        | //profesor[2]/nombre/preceding-sibling::*    | Selecciona los hermanos anteriores       |
   +-------------+--------------------------+----------------------------------------------+------------------------------------------+

Predicados
==========
El :dfn:`predicado` es la parte de la ruta que permite añadir condiciones al
filtro al que acompaña y se escribe entre corchetes. Por ejemplo:

.. code-block:: xquery

   //profesor[@sexo = 'hombre']

selecciona, entre todos los nodos *profesor*, sólo los que representan
profesores varones.

Dos son aspectos fundamentales a la hora de componer un predicado:

* Al representar el predicado una condición, la expresión se evalúa a verdadero
  o falso. En el ejemplo, comprobábamos unas igualdad.

* Las rutas *XPath* expresadas dentro del predicado, si son relativas, son
  relativas al nodo adyacente (*profesor* en el caso del ejemplo). En
  consecuencia, ``@sexo`` es el atributo *sexo* del profesor en cuestión.

.. note:: Para poder explicar mejor los predicados supondremos  a lo largo de
   estas explicaciones que un *profesor* puede tener ninguno, uno o varios
   apodos, esto es, que su definición usando |DTD| es:

   .. code-block:: dtd

      <!ELEMENT profesor (apelativo*, nombre, apellidos, departamento)>

Para expresar condiciones necesitamos *operadores* y *funciones*, aunque ni unos
ni otras deben forzosamente aparecer dentro de un predicado. Por ejemplo, esto
es una expresión *XPath* válida:

.. code-block:: xquery

   1 + 1

que devuelve **2** y esta otra, que devuelve el número de profesores, también:

.. code-block:: xquery

   count(//profesor)

Sin embargo, como habitualmente aparecen dentro de predicados las introduciremos
como apartados dentro de este epígrafe.

Operadores
----------
Dentro de los predicados pueden usarse los siguientes operadores:

.. table:: **Operadores aritméticos**

   ========== ================
    Operador   Significado
   ========== ================
    \+         Suma
    \-         Resta
    \*         Multiplicación
    div        División
    mod        Módulo (resto)
   ========== ================

.. table:: **Operadores lógicos**

   ========== ================
    Operador   Significado
   ========== ================
    =          Igualdad
    !=         Desigualdad
    <          Menor
    <=         Menor o igual
    >          Mayor
    >=         Mayor o igual
    and        Conjunción
    or         Disyunción
    not()      Negación
   ========== ================

**Ejemplos**::

   //profesor[@sexo = 'hombre']
   //profesor[nombre != 'José']
   //profesor[not(nombre = 'José')]
   //profesor[@sexo = 'hombre' and departamento = 'Historia']

.. note:: Pueden yuxtaponerse dos predicados y en ese caso deberán cumplirse
   ambos predicados. Por tanto, el último ejemplo es equivalente a:

   .. code-block:: xquery

      //profesor[@sexo = 'hombre'][departamento = 'Historia']

Funciones
---------
Junto a nodos y operadores, en los predicados\ [#]_ también es posible usar
funciones. En el sitio para desarrolladores de :program:`mozilla` puede
consultarse `una relación completa de funciones para XPath 1.0
<https://developer.mozilla.org/en-US/docs/Web/XPath/Functions>`_, de las cuales
aquí citaremos algunas muy socorridas:

`count() <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/count>`_
   Cuenta el número de nodos. Por ejemplo, podemos seleccionar los profesores
   que tienen más de un apelativo de este modo:

   .. code-block:: xquery

      //profesor[count(apelativo) > 1]

`local-name() <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/local-name>`_
   Devuelve el nombre del elemento (sin el espacio de nombres). Si no se incluye
   como argumento un nodo, se devuelve el nombre del nodo actual. Por ejemplo:

   .. code-block:: xquery

      //profesor/*[local-name() = 'apelativo' or local-name() = 'nombre']

   selecciona los nodos hijo de profesor que son *apelativo* o *nombre*.

`not() <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/not>`_
   Invierte el resultado lógico de la expresión. Ya se trató al hablar de los
   operadores.

.. _xpath-position:

`position() <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/position>`_
   Devuelve la posición del elemento actual. Para seleccionar el segundo
   profesor se puede hacer:

   .. code-block:: xquery

      //profesor[position() = 2]

   que puede simplificarse simplemente a:

   .. code-block:: xquery

      //profesor[2]

   .. warning:: A diferencia de lo que suele ocurrir en Informática, el primer
      elemento se identifica con la posición **1**, no con la **0**.

   .. note:: Para indicar el último, puede usarse la función `last()
      <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/last>`_.

`sum() <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/sum>`_
   Suma los nodos que se incluyen como argumento, supuesto que estos sean
   números.

XPath 1.0
*********
Las aspectos introducidos hasta ahora sobre *XPath* son generales e
independientes de qué versión utilicemos. Han sido expuestos de forma tan
general que pecan (a sabiendas) de superficialidad y dejan aún muchos aspectos
indefinidos. Por ejemplo, la expresión:

.. code-block:: xquery

   //profesor[@casillero = 28]

¿Funciona o no funciona realmente? Porque quizás es necesario escribir el número
28 entre comillas si el valor del atributo es una cadena. Hay, pues, que afinar
para poder escribir las expresiones con propiedad.

Para empezar hay que aclarar dos aspectos importantes:

.. _xpath1-result:

**Resultado**
   esto es, ¿qué devuelve una expresión *XPath*? En la versión 1.0, se pueden
   obtener resultados de dos naturalezas distintas:

   #. *Valores atómicos*, que se devuelven en expresiones como:

      .. code-block:: xquery

         1 = 1

      o:

      .. code-block:: xquery

         1 + 1

      o:

      .. code-block:: xquery

         count(//profesor)

   #. Un *conjunto de nodos* (a veces constituido por un solo nodo), que es lo que
      devuelven expresiones como:

      .. code-block:: xquery

         //profesor/nombre

      que devuelve un conjunto de nodos elemento, o esta:

      .. code-block:: xquery

         //profesor/@id

      que devuelve un conjunto de nodos atributo, o esta:

      .. code-block:: xquery

        //profesor[@id = 'p28']/@casillero

      que devuelve un conjunto de nodos atributo, constituido por un nodo solo.

      .. note:: Obsérvese que se ha usado la palabra "conjunto" y no
         "secuencia". Es importante el matiz, porque las secuencias ordenan sus
         elementos, mientra que los conjuntos, no. Esto quiere decir, que los
         conjuntos de nodos, en teoría no aseguran cuál es el orden en que se
         obtendrán nodos. En la práctica, sin embargo, los nodos siempre se
         devuelven en el orden en que se encuentran en el documento |XML|.

.. _xpath1-datatypes:

**Tipos de datos**
   ¿Cuáles son los tipos de datos (no de nodos, que ya hemos enumerado) que
   reconoce XPath 1.0? Solamente **4**:

   #. Booleanos.
   #. Números.
   #. Cadenas.
   #. Conjuntos de nodos.

   Es muy conveniente tener presente esto, porque los operadores pueden
   comportarse de distinto modo según sea el tipo de los operandos y también
   habrá que saber cómo se actua cuando los operandos son de distinto tipo.

Por tanto, para afinar por completo nuestro conocimiento de *XPath*, es
necesario saber cómo realiza *XPath* la **evaluación** de las operaciones. Por
ejemplo, observe esta expresión aparentemente simple:

.. code-block:: xquery

   //profesor[nombre = "José"]

Intuitivamente entendemos que esta expresión devuelve el conjunto de profesores
(en puridad, nodos profesor) cuyo nombre es "*José*". Sin embargo, si
profundizamos un poco, llegaremos a la conclusión de que "José" es un cadena,
pero el nodo ``nombre`` con el que se compara no lo es: es un nodo elemento que,
a su vez contiene un nodo texto, cuyo valor si es una cadena:

.. code-block:: xquery

   //profesor[nombre/text() = "José"]

¿Tendríamos que haber expresado la comparación así para que ambos operandos
fueran una cadena? Lo cierto es que no llega a ser necesario y la primera
expresión también funciona, porque existen mecanismos de conversión automática
de tipos. Este es un aspecto que debemos revisar.

**Conversión de tipos**
   Al evaluarse expresiones es común que se realicen conversiones automáticas de
   tipos, aunque pueden forzarse algunas conversiones utilizando las funciones
   `boolean()
   <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/boolean>`_,
   `string()
   <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/string>`_ o
   `number()
   <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/number>`_.

   Las conversiones **automáticas** operan del siguiente modo:

   .. rst-class:: simple

   #. Si el operador es ``=`` o ``!=`` y alguno de los dos operandos es booleano,
      el otro se convertirá a booleano; si no es así y uno de los dos es número, el
      otro se convierte a número; y en cualquier otro caso, ambos se convierten a
      cadena.

   #. Si los operadores son de comparación (``<``, ``<=``, ``>`` y ``>=``) los
      operandos se convierten a número.

      .. warning:: Nótese que esto implica que en *XPath* 1.0 no pueden
         compararse alfabéticamente cadenas. Y como no existe el tipo "fecha",
         no pueden compararse fechas (que son cadenas), aunque tengan el formato
         ``AAAA-MM-DD``. Para comparar fechas, primero hay que quitar los
         guiones para que quede la cadena ``AAAAMMDD`` que sí puede convertirse
         en un número. Por ejemplo, si queremos comprobar si una nodo fecha es
         anterior al 21 de diciembre de 2020:

         .. code-block:: xquery

            translate(fecha, "-", "") < 20201221

         En esta expresión hemos usado la función para cadenas `translate
         <https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/translate>`_.

   #. Ante operadores aritméticos, ambos operandos se convierten a número.

   Otro aspecto a considerar es qué resultado produce la conversión a otro tipo:

   .. rst-class:: simple

   * *Conversión a cadena*:

     - Los números se convierten a cadenas según lo que se esperaría de ellos.
     - Los valores booleanos *false* y *true* se convierten a las cadenas "false" y
       "true".
     - Un conjunto de nodos se convierte a cadena, convirtiendo a cadena el primero
       de los nodos. Si el conjunto está vacío, entonces se obtiene la cadena
       vacía. El valor de cadena de un nodo es el valor del atributo, si el nodo es
       un nodo atributo; o la concatenación de los nodos de texto descendientes, si
       el nodo es un nodo elemento.

   * *Conversión a número*:

     - Las cadenas que representan número son convertidas al número equivalente; si
       no representan ningún número, se obtiene **NaN**.
     - *true* se convierte a **1**, y *false* a **0**.
     - Para convertir en número un conjunto de nodos se convierte primero el
       conjunto en cadena.

   * *Conversión a booleano*:

     - Los números negativos y positivos se consideran verdaderos; **0** y **NaN**
       se consideran falsos.
     - Un conjunto de nodos es verdadero, a menos que esté vacío. Esta es la razón
       por la que para seleccionar los profesores que no tienen apelativo basta con
       hacer:

       .. code-block:: xquery

         //profesor[not(apelativo)]

     - Una cadena es verdadera, a menos que sea la cadena vacía.

   Sabido esto ya podemos desentrañar el misterio de por qué funciona:

   .. code-block:: xquery

      //profesor[nombre = "José"]

   El primer operando, "nombre", es un conjunto de nodos elemento que contiene
   un único nodo elemento y el segundo operando es una cadena. Como el operador
   es "=", esto implica que "nombre" se convierte a cadena. Esto implica que el
   primer elemento del conjunto (sólo hay uno en cualquier caso), se transforma
   a cadena. ¿Cómo se transforma un nodo elemento a cadena? Se yuxtaponen los
   valores de todos los nodos de texto que contiene. Sólo tiene uno, el que
   contiene el propio nombre, por lo que la comparación se puede llevar a cabo.

**Pluralidad**
   Existe, además del de la conversión, otro aspecto a tener en cuenta.
   Recordemos que habíamos modificado el |DTD| para que un profesor pudiera
   tener varios apodos. ¿Cómo encontraríamos los profesores a los que se conoce
   como "Pepe"? La  respuesta inmediata es:

   .. code-block:: xquery

      //profesor[apodo = "Pepe"]

   que es correcta, pero que tiene más miga de la que aparenta. Descontado el hecho
   de que hemos escrito :code:`apodo` y no :code:`apodo/text()` (que acabamos de
   explicar por qué funciona), un mismo profesor puede tener varios apodos, así
   que el operador de la izquierda no tiene que ser un único nodo, puede ser un
   conjunto de nodos, caso de que a nuestro profesor *don José*, lo conozcan
   como *Pepe*, pero también como *Pepito*. Así que esa comparación no es de uno
   contra uno, sino de varios contra uno, y en otros casos nos podríamos
   encontrar con operaciones binarias\ [#]_ de varios contra varios.

   Cuando las operaciones implican conjuntos de nodos, nos encontramos con lo
   que denominaremos :dfn:`el problema de la pluralidad`. *XPath* lo resuelve
   del siguiente modo:

   #. Cuando se compara una pluralidad de nodos con un único valor, la expresión es
      verdadera con que al menos uno de los nodos de la pluralidad cumpla con la
      expresión. En consecuencia, en el ejemplo anterior bastaría con que uno de
      los apodos del profesor fuera "Pepe" para que ese profesor quedara
      seleccionado.

   #. Cuando ambos operandos de las expresión son una pluralidad de nodos, la
      expresión es verdadera si hay un nodo del primer conjunto y un nodo del
      segundo conjunto, que al ser comparados entre sí como cadenas hacen que la
      expresión sea verdadera.

   .. caution:: Es importante tener presente que cuando uno o los dos operandos son
      una pluralidad, lo contrario a:

      .. code-block:: xquery

         //profesor[apelativo = "Pepe"]

      no es:

      .. code-block:: xquery

         //profesor[apelativo != "Pepe"]

      sino:

      .. code-block:: xquery

         //profesor[not(apelativo = "Pepe")]

      Sólo esta segunda expresión nos devolvería los nodos de los profesores cuyo
      apelativo no sea "Pepe", ya que la segunda expresión sería cierta con que
      alguno de los apodos del profesor no fuera "Pepe". Por ejemplo, un
      profesor que tenga por apodos "Pepe" y "Pepito" hace verdadero el primer
      predicado, pero también el segundo, ya que "Pepito" no es igual a "Pepe".
      Sólo el tercer predicado es cierto cuando ninguno de los apodos del
      profesor es "Pepe".

XPath 2.0
*********

XQuery
******

.. XQuery:
   https://www.adictosaltrabajo.com/2013/08/06/introduccion-x-query/
   https://www.ticarte.com/contenido/ejercicios-practicos-de-xquery

Ejercicio resuelto
******************
Dado el |XML| :ref:`propuesto para representar el negocio de una cadena de
restaurantes <xml-resueltos>`, determine las expresion *XPath* apropiadas para:

#. Obtener todas las recetas disponibles.

   .. code-block:: xquery

      //receta

#. Obtener el nodo que representa la receta de nombre "ensalada".

   .. code-block:: xquery

      //receta[@nombre="ensalada"]

#. Obtener la carta del restaurante de identificador "re01".

   .. code-block:: xquery

      /cadena/restaurante[@id="re01"]/carta

#. Obtener el código postal del restaurante "El tragón feliz"-

   .. code-block:: xquery

      /cadena/restaurante[@nombre="El dragon feliz"]/domicilio/cp

#. Contar las recetas de las que dispone la cadena.

   .. code-block:: xquery

      count(//receta)

#. Contar cuántos ingredientes necesita la receta de la *ensalada*.

   .. code-block:: xquery

      count(//receta[@nombre="ensalada"]/ingrediente)

#. Contar cuántos ingredientes de "ensalada" se deben medir en gramos.

   .. code-block:: xquery

      count(//receta[@nombre="ensalada"]/ingrediente[@unidad="gramo"])

#. Obtener la carta del restaurante "El tragón feliz".

   .. code-block:: xquery

      /cadena/restaurante[@nombre="El tragón feliz"]/carta

#. Obtener el nombre de las recetas en las que se usa *lechuga*.

   .. code-block:: xquery

      //receta[ingrediente/@nombre = "lechuga"]/@nombre

#. Obtener el nombre de las recetas en las que **no** se usa *lechuga*.

   .. code-block:: xquery

      //receta[not(ingrediente/@nombre = "lechuga")]/@nombre

#. Obtener el identificador de los restaurantes en los que se sirven tapas.

   .. code-block:: xquery

      /cadena/restaurante[carta/plato/@tipo = "tapa" ]/@id

   o mejor::

      /cadena/restaurante[carta/plato[contains(@tipo, "tapa")]]/@id

#. Obtener el identificador de los restaurantes en los que **no** se sirven tapas.

   .. code-block:: xquery

      /cadena/restaurante[carta/plato[not(contains(@tipo, "tapa"))]]/@id

#. Obtener el nombre de los restaurantes con más de 10 platos en la carta.

   .. code-block:: xquery

      /cadena/restaurante[count(carta/plato) > 10]/@nombre

#. Obtener los nombres de las recetas que se sirven en "El tragón feliz".

   .. code-block:: xquery

      //receta[@id = /cadena/restaurante[@nombre="El tragón feliz"]/carta/plato/@ref]/@nombre

#. Obtener el nombre de los restaurantes situados en la provincia de Huelva
   (hágalo a partir del código postal)

   .. code-block:: xquery

      /cadena/restaurante[substring(domicilio/cp, 1, 2) = "21"]/@nombre

#. Obtener el nombre de las recetas que se sirven como tapa en algún restaurante.

   .. code-block:: xquery

      //receta[@id = /cadena/restaurante/carta/plato[contains(@tipo, "tapa")]/@ref]/@nombre

#. Obtener el nombre de los restaurantes que sirven bocadillos de anchoa.

   .. code-block:: xquery

      /cadena/restaurante[carta/plato/@ref = //receta[@nombre="bocadillo de anchoas"]/@id]/@nombre

#. Contar los restaurantes que usan lechuga en su carta.

   .. code-block:: xquery

      count(/cadena/restaurante[carta/plato/@ref = //receta[ingrediente/@nombre = "lechuga"]/@id])


#. Contar los restaurantes que **no** usan lechuga en su carta.

   .. code-block:: xquery

      count(/cadena/restaurante[not(carta/plato/@ref = //receta[ingrediente/@nombre = "lechuga"]/@id)])

#. ¿Qué receta requiere más aceite? Suponga que el aceite siempre se mide en *cc*.

   .. code-block:: xquery

      //receta[ingrediente[@nombre = "aceite"]/@cantidad >= //receta/ingrediente[@nombre = "aceite"]/@cantidad]

Ejercicios propuestos
*********************

.. include:: /99.ejercicios/30.xpath.rst
   :start-line: 3


.. rubric:: Notas al pie

.. [#] Y no sólo. Ya veremos más adelante.
.. [#] `Operación binaria
   <https://es.wikipedia.org/wiki/Operaci%C3%B3n_binaria>`_ en el sentido de que
   hay involucrados dos operandos y un operador, no en el sentido de que los
   operadores sean números binarios.

.. |W3C| replace:: :abbr:`W3C (W3 Consortium)`
.. |DTD| replace:: :abbr:`DTD (Document Type Definition)`
.. |XSLT| replace:: :abbr:`XSLT (eXtensible Stylesheet Language Transformations)`
.. |CLI| replace:: :abbr:`CLI (Command Line Interface)`

.. _xidel: https://www.videlibri.de/xidel.html
.. _Visual Studio Code: https://code.visualstudio.com
